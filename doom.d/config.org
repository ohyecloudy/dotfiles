* lexical binding

  #+begin_src elisp
    ;;; config.el -*- lexical-binding: t; -*-
  #+end_src

* name, email

  #+begin_src elisp
    (setq user-full-name "Jongbin Oh"
          user-mail-address "ohyecloudy@gmail.com")
  #+end_src

  GPG configuration, email clients, file templates, snippets 등에 사용할 신원 정보 세팅

* auth-source

  #+begin_src elisp
    (after! doom-themes
      (setq auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc")))
  #+end_src

  디폴트값으로 돌림

* emacs-server

  #+begin_src elisp
    (require 'server)
    (server-start)
  #+end_src

  외부에서 파일을 =emacsclientw.exe= 파일을 사용해 현재 열려있는 emacs 인스턴스에 열도록 지원한다

* look

  #+begin_src elisp
    (setq frame-title-format "%b")
  #+end_src

  버퍼 파일 이름을 타이틀바로 표시한다

  #+begin_src elisp
    (setq display-line-numbers-type 'visual)
  #+end_src

  evil 키이동 활용성을 높이려고 visual로 세팅. relative는 folding을 고려하지 않지만 visual은 고려한다.

* hangul

  #+begin_src elisp
    ;; input method도 엮여 있어서 Korean으로 설정 후 utf-8 개별 세팅이 편한다
    (set-language-environment "Korean")
    ;; 한글 환경에서는 cp949 인코딩이 디폴트이기 때문에 utf-8로 세팅
    (prefer-coding-system 'utf-8)
    (set-default-coding-systems 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (setq-default buffer-file-coding-system 'utf-8)
    (if (fboundp 'w32-set-system-coding-system)
        (w32-set-system-coding-system 'utf-8))
    ;; 날짜 표시를 영어로한다. org mode에서 time stamp 날짜에 영향을 준다.
    (setq system-time-locale "C")
    (setenv "LANG" "en_US.UTF-8")
    (setenv "LC_ALL" "en_US.UTF-8")
  #+end_src

  #+begin_src elisp
    (when IS-WINDOWS
      (set-clipboard-coding-system 'cp949))
  #+end_src

  윈도에서는 클립보드 코딩 시스템을 시스템에 맞춰 =cp949= 로 세팅한다.

* font

  #+begin_src org :tangle no
    | 12345678 |   |
    |----------+---|
    | 일이삼사 |   |
  #+end_src

  한글만 크기를 키워서 맞출 수 있는데, 조화롭지 못하다. 참고삼아 보기만 하고 이걸 꼭 맞추려고 노력하지는 않는다.

** macOS

   #+begin_src elisp
     (after! doom-themes
       (when IS-MAC
         (set-face-attribute 'default nil :family "Consolas")
         (set-fontset-font t 'hangul (font-spec :family "D2Coding"))
         (set-face-attribute 'default nil :height 140)
         (set-default 'line-spacing 0)))
   #+end_src

   =doom-font= 심볼에 폰트를 바인딩하면 한글 폰트만 D2Coding으로 변경하는 설정이 제대로 동작하지 않는다. 그래서 무식하게 세팅한다.

** windows

   #+begin_src elisp
     (after! doom-themes
       (when IS-WINDOWS
         (set-face-attribute 'default nil :family "Consolas")
         (set-fontset-font t 'hangul (font-spec :family "D2Coding"))
         (set-face-attribute 'default nil :height 110)
         (set-default 'line-spacing 0)))
   #+end_src

   macos 모듈을 참고해서 키 바인딩을 비슷하게 설정함

   #+begin_src elisp :lexical t
     (when IS-WINDOWS
       (map! :leader
             (:prefix-map ("o" . "open")
              :desc "Reveal in Explorer"           "o" #'+windows/reveal-in-explorer
              :desc "Reveal project in Explorer"   "O" #'+windows/reveal-project-in-explorer
              :desc "Open in git bash"             "i" #'+windows/open-in-bash
              :desc "Open in cmd"                  "I" #'+windows/open-in-cmd)))
   #+end_src

* startup

  #+begin_src elisp
    (setq initial-frame-alist '((fullscreen . maximized)))
  #+end_src

  귀한 emacs. 최대 크기로 시작한다.

* M-x keybinding

  =M-x= 키가 =alt= 키를 눌러야 해서 불편하다. =C-x C-m= 키로도 호출할 수 있게 변경.

  #+begin_src elisp
    (global-set-key (kbd "C-x C-m") 'execute-extended-command)
  #+end_src

* tab -> space

  #+begin_src elisp
    (setq indent-tabs-mode nil)
  #+end_src

* cc-mode

  #+begin_src elisp
    (setq-default c-default-style "bsd"
                  c-basic-offset 4)
  #+end_src

* input

  #+begin_src elisp
    (setq +default-want-RET-continue-comments nil)
  #+end_src

  =RET= 키를 눌렀을 때, 코멘트가 연결되는 기능을 끈다. 한 줄 코멘트가 많아 오히려 번거롭다.

* doom emacs

** online

   #+begin_src elisp :lexical t
     (setopt +lookup-provider-url-alist
             (append '(
                       ("blogs"             "https://google.com/search?q=site:ohyecloudy.com %s")
                       ("chatgpt"           "https://chat.openai.com?q=%s")
                       ("elixir"            "https://hexdocs.pm/elixir/search.html?q=%s")
                       ("flutter"           "https://docs.flutter.dev/search?q=%s")
                       ("google images"     "https://www.google.com/images?q=%s")
                       ("google maps"       "https://maps.google.com/maps?q=%s")
                       ("google"            +lookup--online-backend-google "https://google.com/search?q=%s")
                       ("internet archive"  "https://web.archive.org/web/*/%s")
                       ("naver dict"        "https://dict.naver.com/search.dict?query=%s")
                       ("naver map"         "https://map.naver.com/p/search/%s")
                       ("naver"             "https://search.naver.com/search.naver?query=%s")
                       ("perplexity"        "https://perplexity.ai/search?q=%s")
                       ("wikipedia"         "https://wikipedia.org/search-redirect.php?language=ko&go=Go&search=%s")
                       ("wikipedia en"      "https://wikipedia.org/search-redirect.php?language=en&go=Go&search=%s")
                       ("youtube"           "https://youtube.com/results?aq=f&oq=&search_query=%s")
                       )
                     )
             )
   #+end_src

   선택한 영역이 있을 때, query로 바로 사용한다. 바로 사용하지 않고 디폴트 값으로 정의해 한 번 더 입력을 받는다.

   #+begin_src elisp :lexical t
     (defun my/+lookup/online (query provider)
       "Look up QUERY in the browser using PROVIDER.
     When called interactively, prompt for a query and, when called for the first
     time, the provider from `+lookup-provider-url-alist'. In subsequent calls, reuse
     the previous provider. With a non-nil prefix argument, always prompt for the
     provider.

     QUERY must be a string, and PROVIDER must be a key of
     `+lookup-provider-url-alist'."
       (interactive
        (list (if (use-region-p) (doom-thing-at-point-or-region))
              (+lookup--online-provider current-prefix-arg)))
       (let ((backends (cdr (assoc provider +lookup-provider-url-alist))))
         (unless backends
           (user-error "No available online lookup backend for %S provider"
                       provider))
         (catch 'done
           (dolist (backend backends)
             (cl-check-type backend (or string function))
             (cond ((stringp backend)
                    (funcall +lookup-open-url-fn
                             (format backend
                                     (url-encode-url
                                      ;; region을 선택했을 때, 바로 찾는 게 아니라 read-string 디폴트 값으로 입력을 기다림
                                      (read-string (format "Search for (on %s): " provider)
                                                   (or query (thing-at-point 'symbol t)))))))
                   ((condition-case-unless-debug e
                        (and (fboundp backend)
                             (funcall backend query))
                      (error
                       (setf (alist-get major-mode +lookup--last-provider nil t) nil)
                       (signal (car e) (cdr e))))
                    (throw 'done t)))))))

     (advice-add '+lookup/online :override #'my/+lookup/online)
   #+end_src

   이전 설정을 기억하고 사용하는 경우가 잘 없어서 검색 위치를 물어보는 함수를 =SPC s o= 키에 바인딩

   #+begin_src elisp :lexical t
     (map! :leader
           ;;; <leader> s --- search
           (:prefix-map ("s" . "search")
                        :desc "Look up online (w/ prompt)"   "o" #'+lookup/online-select
                        :desc "Look up online"               "O" #'+lookup/online
                        ))
   #+end_src

* packages

** doom theme

   #+begin_src elisp
     (setq
      doom-theme 'doom-vibrant
      doom-themes-enable-bold nil
      doom-themes-enable-italic nil)
   #+end_src

   한글이 많은 경우 bold, italic 시인성이 별로라서 꺼놓는다.

   #+begin_src elisp
     (doom-themes-visual-bell-config)
   #+end_src

   modeline에 visual bell을 표시한다. 시인성이 좋음.

** org

   #+begin_src elisp :lexical t
     (setq org-roam-directory (file-truename "~/org_roam")
           ;; org-agenda-files (list org-directory) ;; agenda를 사용하면 파일이 많아서 로딩 시간이 너무 오래 걸림
           )
   #+end_src

   [[https://github.com/doomemacs/doomemacs/commit/9a6bcc31f96308bc1659d90e6b7f4fcf7b1e3138][9a6bcc31f9]] 커밋에서 ellipsis를 =[...]= 으로 바꿨다. heading에 link가 있는 경우 ellipsis 문자 뒤에 =_= 문자가 보여서 지저분하다. 그래서 원래대로 기본 =org-ellipsis= 문자를 사용한다.

   #+begin_src elisp :lexical t
     (after! org
       (setq org-ellipsis nil))
   #+end_src

   =[b= =]b= 키가 buffer 이동 키로 바인딩되어 있으나 잘 쓰지 않는다. 그것보다 org block 이동이 더 필요해서 바인딩

   #+begin_src elisp :lexical t
     (after! org
       (map! :map org-mode-map
             :n "]b" #'org-next-block
             :n "[b" #'org-previous-block))
   #+end_src

*** abbrev link

    - property drawers에 abbrev 링크를 정의했을 때, 링크로 인식하지 못한다
    - 디폴트로 에러를 내는 구현을 추가해서 issue abbrev 링크 문자열을 노출

    #+begin_src elisp :lexical t
      (after! org
        (defun my/org-link--expand-abbrev-or-error (type path)
          "Expand TYPE:PATH using #+LINK abbrev rules.
      TYPE is a string like \"wiki\" or \"issue\".
      PATH is the raw link path part (without the TYPE: prefix).
      Return the expanded URL string, or signal user-error if no rule exists."
          (let* ((raw (concat type ":" path))
                 (expanded (org-link-expand-abbrev raw)))
            (if (and expanded (not (string= expanded raw)))
                expanded
              (user-error
               "No #+LINK rule for '%s'. Add e.g. '#+LINK: %s https://.../%%s' (or use #+SETUPFILE)"
               type type))))

        (defun my/org-link--follow-abbrev (type)
          "Return a :follow function for org-link-set-parameters that opens expanded URL."
          (lambda (path _arg)
            (browse-url (my/org-link--expand-abbrev-or-error type path))))

        (defun my/org-link--export-abbrev (type)
          "Return an :export function for org-link-set-parameters that exports as real URL."
          (lambda (path desc backend)
            (let ((url (my/org-link--expand-abbrev-or-error type path)))
              (org-link-make-string url (or desc path)))))

        (org-link-set-parameters
         "wiki"
         :follow (my/org-link--follow-abbrev "wiki")
         :export (my/org-link--export-abbrev "wiki"))

        (org-link-set-parameters
         "issue"
         :follow (my/org-link--follow-abbrev "issue")
         :export (my/org-link--export-abbrev "issue"))
        )
    #+end_src

    #+begin_src org :tangle no
      ,#+LINK: issue https://www.myjira.com/browse/%s
      ,#+LINK: wiki https://www.wiki.com/%s
    #+end_src

    HEADER에 이렇게 정의하면 해당 링크로 열린다.

*** org-roam

    title이 변경될 때, 파일 이름도 같이 바꾼다. [[https://github.com/hlissner/.doom.d/blob/master/config.el][hlissner/.doom.d/blob/master/config.el - github.com]] 에서 가져옴

    #+begin_src elisp :lexical t
      (after! org-roam
        ;; Automatically update the slug in the filename when #+title: has changed.
        (add-hook 'org-roam-find-file-hook #'org-roam-update-slug-on-save-h))
    #+end_src

    org-roam capture template 설정

    #+begin_src elisp :lexical t
      (after! org-roam
        (setq org-roam-capture-templates
              `(("n" "note" plain
                 ,(format "#+title: ${title}\n%%[%s/template/note.org]" org-roam-directory)
                 :target (file "note/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("t" "topic" plain
                 ,(format "#+title: ${title}\n%%[%s/template/topic.org]" org-roam-directory)
                 :target (file "topic/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("w" "work" plain
                 ,(format "#+title: ${title}\n%%[%s/template/work.org]" org-roam-directory)
                 :target (file "work/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("r" "weekly retrospective" plain
                 ,(format "#+title: ${title}\n%%[%s/template/retrospective-weekly.org]" org-roam-directory)
                 :target (file "retrospective/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("e" "retrospective" plain
                 ,(format "#+title: ${title}\n%%[%s/template/retrospective.org]" org-roam-directory)
                 :target (file "retrospective/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("f" "ref" plain
                 ,(format "#+title: ${title}\n%%[%s/template/ref.org]" org-roam-directory)
                 :target (file "ref/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("c" "contact" plain
                 ,(format "#+title: ${title}\n%%[%s/template/contact.org]" org-roam-directory)
                 :target (file "contact/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("b" "book" plain
                 ,(format "#+title: ${title}\n%%[%s/template/book.org]" org-roam-directory)
                 :target (file "book/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("v" "video" plain
                 ,(format "#+title: ${title}\n%%[%s/template/video.org]" org-roam-directory)
                 :target (file "video/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("h" "chopsticks" plain
                 ,(format "#+title: ${title}\n%%[%s/template/note.org]" org-roam-directory)
                 :target (file "chopsticks/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("g" "game" plain
                 ,(format "#+title: ${title}\n%%[%s/template/game.org]" org-roam-directory)
                 :target (file "game/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("o" "coolthings" plain
                 ,(format "#+title: ${title}\n%%[%s/template/coolthings.org]" org-roam-directory)
                 :target (file "coolthings/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("l" "plan" plain
                 ,(format "#+title: ${title}\n%%[%s/template/note.org]" org-roam-directory)
                 :target (file "plan/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("a" "place" plain
                 ,(format "#+title: ${title}\n%%[%s/template/note.org]" org-roam-directory)
                 :target (file "place/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("s" "career" plain
                 ,(format "#+title: ${title}\n%%[%s/template/note.org]" org-roam-directory)
                 :target (file "career/%<%Y%m%d%H%M%S>-${slug}.org")
                 :unnarrowed t)
                ("p" "project" plain
                 ,(format "#+title: ${title}\n%%[%s/template/project.org]" org-roam-directory)
                 :target (file "project/%<%Y%m%d>-${slug}.org")
                 :unnarrowed t))
              org-roam-dailies-capture-templates
              `(("d" "default" plain ""
                 :target (file+head "%<%Y-%m-%d>.org" ,(format "%%[%s/template/journal.org]" org-roam-directory))))))
    #+end_src

    backlink를 카테고리로 나눠서 분류해 보여준다. [[https://github.com/hlissner/.doom.d/blob/master/config.el][hlissner/.doom.d/blob/master/config.el - github.com]] 에서 가져옴

    #+begin_src elisp :lexical t
      (after! org-roam
        ;; List dailies and zettels separately in the backlinks buffer.
        (advice-add #'org-roam-backlinks-section :override #'org-roam-grouped-backlinks-section))
    #+end_src

    backlinks buffer 상단에 id, type, aliases 정보를 보여줌. [[https://github.com/hlissner/.doom.d/blob/master/config.el][hlissner/.doom.d/blob/master/config.el - github.com]] 에서 가져옴.

    #+begin_src elisp :lexical t
      (after! org-roam
        ;; Add ID, Type, Tags, and Aliases to top of backlinks buffer.
        (advice-add #'org-roam-buffer-set-header-line-format :after #'org-roam-add-preamble-a))
    #+end_src

    backlinks buffer 기본 표시 레벨을 2로 조정

    #+begin_src elisp :lexical t
      (after! org-roam
        (add-hook 'org-roam-buffer-postrender-functions #'magit-section-show-level-2))
    #+end_src

    =SPC n r t= 키를 누르면 org roam 변경 사항에 대한 커밋을 만들어낸다

    #+begin_src elisp :lexical t
      (after! org-roam
        (map! :leader
              (:prefix-map ("n" . "notes")
                           (:prefix ("r" . "roam")
                            :desc "commit org-roam" "t" #'my/org-roam-commit))))
    #+end_src

    오늘을 기준으로 YYYY-wWW(예. 2025-w31) 형식의 node를 찾는 함수를 =SPC n r w= 키에 바인딩함.

    #+begin_src elisp :lexical t
      (defun my/week-number-string (&optional time)
        "Return ISO week string (YYYY-wWW) for TIME or now"
        (let ((target (or time (current-time))))
          (format "%s-w%s"
                  (format-time-string "%Y" target)
                  (format-time-string "%V" target))))

      (defun my/org-roam-find-today-week ()
        "Find org-roam node for the current ISO week number like 2025-w31"
        (interactive)
        (org-roam-node-find nil (my/week-number-string)))

      (after! org-roam
        (map! :leader
              (:prefix-map ("n" . "notes")
                           (:prefix ("r" . "roam")
                            :desc "find today week" "w" #'my/org-roam-find-today-week))))
    #+end_src

    현재 파일에 기록된 YYYY_wWW를 기준으로 week를 shift한 node를 찾는 함수를 =SPC n r W= 키에 바인딩함.

    #+begin_src elisp :lexical t
      (defun my/shift-week-number (week-string delta)
        "Shift WEEK-STRING (YYYY-wWW) by DELTA weeks.
      Return new week string like '2025-w30' or '2025-w32'."
        (let* ((parts (split-string week-string "-w"))
               (year (string-to-number (car parts)))
               (week (string-to-number (cadr parts)))
               ;; 1월 4일이 ISO week 1에 항상 포함된다는 규칙을 활용해 ISO 주차 첫날 계산
               (date (encode-time 0 0 0
                                  4 1 year))
               (current-week-time (time-add date (days-to-time (* 7 (1- week)))))
               (shifted-time (time-add current-week-time (days-to-time (* 7 delta)))))
          (my/week-number-string shifted-time)))

      (defun my/org-roam-find-shift-week (delta)
        "Find org-roam node for current buffer's week number shifted by DELTA weeks."
        (interactive "nWeek delta: ")
        (let* ((file (buffer-file-name)))
          (if (and file
                   (string-match "\\([0-9]\\{4\\}_w[0-9]\\{2\\}\\)" (file-name-base file)))
              (let* ((week-str (match-string 1 (file-name-base file)))
                     (refined (replace-regexp-in-string "_" "-" week-str))
                     (shifted (my/shift-week-number refined delta)))
                (org-roam-node-find nil shifted))
            (message "Current buffer '%s' is not a YYYY-wWW file." (or file "<no-file>")))))

      (after! org-roam
        (map! :leader
              (:prefix-map ("n" . "notes")
                           (:prefix ("r" . "roam")
                            :desc "find shift week" "W" #'my/org-roam-find-shift-week))))
    #+end_src

*** org-roam optimization

    =org-roam-node-find=, =org-roam-node-insert= 에서 호출하는 =org-roam-node-read--completions= 함수가 느려서 최적화를 진행

    디폴트 소팅을 꺼서 시간을 조금이라도 더 아낀다.

    #+begin_src elisp :lexical t
      (after! org-roam
        (setq org-roam-node-default-sort nil))
    #+end_src

    [[https://github.com/skeeto/emacs-memoize/][skeeto/emacs-memoize/ - github.com]] 설치

    #+begin_src elisp :tangle packages.el
      (package! memoize)
    #+end_src

    =org-roam-node-read--completions= 함수 [[http://ohyecloudy.com/pnotes/archives/497/][메모이제이션]]. [[https://www.reddit.com/r/orgmode/comments/s8xv5j/orgroam_slows_down_as_nodes_increase_solution/][Org-roam slows down as nodes increase.. solution? - reddit.com]]에서 코드를 가져옴.

    강제 메모이제이션 클리어는 =SPC n r c= 에 바인딩함

    #+begin_src elisp :lexical t
      (after! org-roam
        (require 'memoize)

        (memoize 'org-roam-node-read--completions "10 minute")

        (defun memoize-force-update (func &optional timeout)
          (when (get func :memoize-original-function)
            (progn (memoize-restore func)
                   (memoize func timeout))))

        (defun my/force-update-org-roam-node-read-if-memoized (&optional timeout)
          (interactive)
          (memoize-force-update 'org-roam-node-read--completions
                                (if timeout timeout memoize-default-timeout)))

        (run-with-idle-timer 60 t #'my/force-update-org-roam-node-read-if-memoized)

        (map! :leader
              (:prefix-map ("n" . "notes")
                           (:prefix ("r" . "roam")
                            :desc "Clear memoization" "c"
                            #'my/force-update-org-roam-node-read-if-memoized))))
    #+end_src

*** org settings

    #+begin_src elisp
      (after! org
        (setq
         ;; quote와 verse block도 배경 색상을 바꾼다
         org-fontify-quote-and-verse-blocks t
         ;; heading *를 한 개만 보여준다.
         org-hide-leading-stars t
         ;; done 해드라인 폰트 변경을 하지 않는다. 색상 때문에 doom theme 변경시 제대로 안 보임
         org-fontify-done-headline nil
         ;; 9.5부터 default 값이 바뀜
         org-adapt-indentation t
         ;; modeline에 보이는 org clock 정보가 너무 길어서 줄임
         org-clock-string-limit 30
         ;; 트리를 접을 때, heading 사이에 빈 라인을 없앤다
         org-cycle-separator-lines 0
         ;; 순서 없는 목록(unordered list)에서 bullet으로 들여쓰기를 할 때마다 +, -를 번갈아 사용한다
         org-list-demote-modify-bullet '(("+" . "-") ("-" . "+"))
         ;; #+STARTUP: fold 를 기본값으로 한다. org 파일을 열었을 때, overview를 가장 먼저 보고 싶기 때문
         org-startup-folded 'show2levels))
    #+end_src

    ui 관련 설정들

    #+begin_src elisp
      (after! org
        (setq org-startup-indented nil
              org-src-preserve-indentation nil))
    #+end_src

    emacs에서 org mode일 때, indentation을 적용하는 기능을 끈다. 이 기능을 끄면 emacs가 아닌 다른 에디터로 org 파일을 볼 때도 space로 indentation을 적용한 상태이다.

    이 상태에서 =org-src-preserve-indentation= 심볼에 nil이 아닌 값이 바인딩되었다면 소스 코드 블럭이 heading 본문 indentation과 상관없이 라인 앞에 붙어 있다. 원래 소스 코드의 indentation을 유지하기 때문이다. 소스 코드 블럭도 똑같이 indentation을 지키도록 =nil= 값을 바인딩한다.

    #+begin_src elisp
      (after! org
        (setq org-todo-keywords
              '((sequence
                 "TODO"
                 "STARTED"
                 "|"
                 "DONE"))
              org-todo-keyword-faces
              '(("STARTED" . +org-todo-active))))
    #+end_src

    org 모듈에서 정의한 =+org-todo-active= 페이스를 사용하기에 org 모듈을 로드한 후에 실행해야 한다.

    #+begin_src elisp
      (after! org
        (setq org-blank-before-new-entry
              '((heading . t) (plain-list-item . nil))))
    #+end_src

    heading 사이에는 반드시 빈 줄이 들어가게 한다. plan list item 사이에는 무조건 제거한다.

    #+begin_src elisp
      (after! evil-org
        (map! :map evil-org-mode-map
              :ni [C-return]   #'org-insert-heading-respect-content
              :ni [C-S-return] #'org-insert-todo-heading-respect-content))
    #+end_src

    doom에서 =C-RET= 키는 아래에 추가 =C-S-RET= 키는 위로 추가로 바인딩을 변경한다. 새로 함수를 추가해서 해당 함수에 바인딩하는데, 해당 함수에 =org-blank-before-new-entry= 심볼 값이 반영이 안 되어 있어서 org mode의 디폴트 함수로 바인딩을 했다.

    =evil-org= 모드 맵도 똑같이 수정한다.

    #+begin_src elisp
      (after! org
        (setq org-M-RET-may-split-line '((default . t))))
    #+end_src

    =M-RET= 키로 라인을 분리할 수 있게 한다. org module에서 nil 값을 바인딩한 걸 디폴트 값으로 돌림.

    #+begin_src elisp
      (defun my-org-clock-in-if-starting ()
        "Clock in when the task is marked STARTED."
        (when (and (string= org-state "STARTED")
                   (not (string= org-last-state org-state)))
          (org-clock-in)))
      (add-hook 'org-after-todo-state-change-hook
                #'my-org-clock-in-if-starting)
      (advice-add 'org-clock-in
                  :after (lambda (&rest _)
                           (org-todo "STARTED")))
      ;; 다른 org-clock 시작으로 clock-out 됐을 때, todo도 바꿔준다
      (add-hook 'org-clock-out-hook
                (lambda ()
                  (when (and (boundp 'org-state)
                             (string= org-state "STARTED"))
                    (org-todo "DONE"))))
    #+end_src

    =STARTED= 키워드로 변경하면 =org-clock= 을 시작한다. =TODO= 상태에서 =STARTED= 상태로 변경되면 자동으로 시간 기록이 되게 하려고 추가한 기능. [[http://ohyecloudy.com/emacsian/2017/07/01/org-clocking-time-with-emacs-todo-state/][#orgmode TODO 상태와 org-clock은 같이 움직인다 - ohyecloudy.com]] 참고

    #+begin_src elisp
      (after! org-clock
        (setq org-clock-persist-query-resume nil))
    #+end_src

    active clock이 있을 때, 물어보지 않고 재개한다. [[http://ohyecloudy.com/emacsian/2017/10/14/org-clock-persistence/][#orgmode emacs를 꺼도 org-clock은 굴러간다 - ohyecloudy.com]] 참고

    #+begin_src elisp
      (after! org-clock
        (setq org-clock-idle-time 15))
    #+end_src

    15분을 자리비움 감지 기준으로 설정. [[http://ohyecloudy.com/emacsian/2017/11/04/org-dealing-with-idle-time/][#orgmode idle 시간 다루기 - ohyecloudy.com]] 참고

    #+begin_src elisp
      (after! org
        ;; org-set-effort 함수 실행 시 나오는 preset 리스트
        (setq org-global-properties
              '(("Effort_ALL" .
                 "1h 2h 3h 4h 8h 16h 24h 32h 40h 0.5h")))

        ;; org-columns에서 effort를 볼 수 있게 추가
        (setq org-columns-default-format "%50ITEM(Task) %10Effort{:} %10CLOCKSUM")

        ;; org-clock-report 기본 프로퍼티
        (setq org-clock-clocktable-default-properties
              '(:maxlevel 2 :scope file :narrow 30! :properties ("effort"))))
    #+end_src

    추정 시간에 관련된 설정. 추정 시간 입력시 preset 리스트를 추가하고 =org-columns= 명령과 =org-clock-report= 명령에서 추정 시간을 볼 수 있게 세팅. [[http://ohyecloudy.com/emacsian/2017/09/09/org-effort-estimates/][#orgmode 추정(estimate) 작업 시간 기록 - ohyecloudy.com]] 참고

    #+begin_src elisp
      (after! org
        (setq org-duration-format (quote h:mm)))
    #+end_src

    기간 포맷으로 시간:분 사용. 24시가 넘어갈 때, 1d로 표현하는 게 보기 싫어서 세팅. [[http://ohyecloudy.com/emacsian/2017/11/25/org-duration-format/][#orgmode 하루가 넘어가도 clock table 기간 필드에 시간과 분으로만 표시 - ohyecloudy.com]] 참고

    #+begin_src elisp
      (after! org
        (defun org-columns-with-visual-line-mode ()
          (interactive)
          (org-columns)
          (visual-line-mode)))
    #+end_src

    =org-columns= 모드를 켤 때, 자동 줄바꿈을 해주는 =visual-line-mode= 를 활성화한다. [[http://ohyecloudy.com/emacsian/2020/03/15/org-column-view-with-visual-line-mode/][#orgmode column view를 활성화하면 꺼지는 줄 바꿈(word wrap)을 켜는 방법 - ohyecloudy.com]] 참고

    #+begin_src elisp
      (after! org
        (setq org-show-notification-handler (lambda (notification) (message notification))))
    #+end_src

    쓴 시간이 effort를 넘었을 때, 나오는 desktop notification을 끈다. Task 'some tasks' should be finished by now. (1:00)

    #+begin_src elisp
      (defun my/org-open-at-point-other-window ()
        (interactive)
        (let ((org-link-frame-setup (cons (cons 'file 'find-file-other-window) org-link-frame-setup)))
          (org-open-at-point)))

      (after! evil-org
        (map! :map evil-org-mode-map
              :ni "C-c C-RET"      #'my/org-open-at-point-other-window
              :ni "C-c C-<return>" #'my/org-open-at-point-other-window))
    #+end_src

    현재 윈도우에서 파일을 여는 게 기본 동작이다. 기본 동작을 유지하고 =C-c C-RET= 키로는 다른 윈도로 링크를 열게 한다.

    #+begin_src elisp
      (after! org
        (setq org-enforce-todo-dependencies nil))
    #+end_src

    자식 todo가 완료되어야만 부모 heading을 done으로 바꿀 수 있는 제한을 푼다. org clock out을 DONE 상태와 연동해서 사용하기 때문.

    #+begin_src elisp
      (after! org
        (setq org-tag-alist '((:startgroup . nil)
                              ("blog" . ?b)
                              (:endgroup . nil))))
    #+end_src

    미리 정의된 tag를 설정

    #+begin_src elisp
      (setq org-element-use-cache nil)
    #+end_src

    #+begin_example
       Please report this to Org mode mailing list (M-x org-submit-bug-report). Disable showing Disable logging
      Warning (org-element-cache): org-element--cache: Org parser error in *org-ai-on-region*::2016. Resetting.
       The error was: (error "Invalid search bound (wrong side of point)")
       Backtrace:
      nil
    #+end_example

    이런 에러가 간간히 발생해서 cache를 끈다.

*** ox-gfm

    #+begin_src elisp :tangle packages.el
      (package! ox-gfm)
    #+end_src

    #+begin_src elisp
      (eval-after-load "org"
        '(require 'ox-gfm nil t))
    #+end_src

    =C-c C-e= 키로 =org-export-dispatch= 함수를 호출하면 Github Flavored Markdown으로 export할 수 있다

    [[https://github.com/larstvei/ox-gfm][larstvei/ox-gfm - github.com]]

*** org babel

**** ob-translate

     #+begin_src elisp :tangle packages.el
       (package! ob-translate)
     #+end_src

     #+begin_src elisp
       (setq ob-translate:default-dest "ko")
     #+end_src

     #+RESULTS:
     : ko

     #+begin_src translate :src en :dest ko :tangle no
       Doom is a configuration framework for GNU Emacs tailored for Emacs bankruptcy veterans who want less framework in their frameworks, a modicum of stability (and reproducibility) from their package manager, and the performance of a hand rolled config (or better). It can be a foundation for your own config or a resource for Emacs enthusiasts to learn more about our favorite operating system.
     #+end_src

     #+RESULTS:
     : Doom은 프레임워크의 프레임워크가 적고 패키지 관리자의 약간의 안정성(및 재현성)과 수동 구성(또는 그 이상)의 성능을 원하는 Emacs 파산 베테랑을 위해 맞춤화된 GNU Emacs용 구성 프레임워크입니다. Emacs 애호가가 선호하는 운영 체제에 대해 자세히 알아볼 수 있는 자체 구성 또는 리소스의 기초가 될 수 있습니다.

     [[https://github.com/krisajenkins/ob-translate][krisajenkins/ob-translate - github.com]]

     #+begin_example
       google-translate--search-tkk: Search failed: ",tkk:'"
     #+end_example

     이런 에러 메시지가 뜬다.

     #+begin_src elisp
       (defun google-translate--search-tkk ()
         "Search TKK."
         (list 430675 2721866130))
     #+end_src

     [[https://github.com/atykhonov/google-translate/issues/137][atykhonov/google-translate/issues/137 - github.com]] 글을 참고해서 =google-translate--search-tkk= 함수를 재정의함

**** ob-http

     #+begin_src elisp :tangle packages.el
       (package! ob-http)
     #+end_src

     #+begin_src elisp
       (org-babel-do-load-languages 'org-babel-load-languages
                                    (append org-babel-load-languages
                                            '((http . t))))
     #+end_src

     [[https://github.com/zweifisch/ob-http][zweifisch/ob-http - github.com]]

     src 블럭으로 http 응답을 사용할 수 있다.

     #+begin_src http :pretty :tangle no
       GET https://api.github.com/repos/ohyecloudy/dotfiles/languages
     #+end_src

     #+RESULTS:
     #+begin_example
     {
       "Emacs Lisp": 126668,
       "Shell": 90476,
       "YASnippet": 9424,
       "Batchfile": 3991,
       "Vim script": 2181,
       "Python": 945,
       "JavaScript": 719,
       "AutoHotkey": 405
     }
     #+end_example

*** org-cv

    #+begin_src elisp :tangle packages.el
      (when IS-MAC
        (package! ox-moderncv
          :recipe (:host github :repo "ohyecloudy/org-cv")))
    #+end_src

    #+begin_src elisp
      (when IS-MAC
        (require 'ox-moderncv))
    #+end_src

    org 문서를 moderncv로 export하는 패키지를 설치한다.

*** org copy link

    #+begin_src elisp
      (defun my/org-copy-link-at-point ()
        (interactive)
        (let ((link (org-element-property :raw-link (org-element-context))))
          (when link
            (kill-new link))))
    #+end_src

    커서가 위치한 org element에 link 프로퍼티가 있으면 클립보드로 복사하는 함수.

    #+begin_src elisp
      (after! org
        (map! :map org-mode-map
              :localleader
              (:prefix ("l" . "links")
                       "y" #'my/org-copy-link-at-point)))
    #+end_src

    org mode에서 =SPC m l y= 키에 바인딩.

*** org export

    #+begin_src elisp
      (after! org
        (setq org-export-with-sub-superscripts nil))
    #+end_src

    [[http://ohyecloudy.com/emacsian/2019/01/12/org-export-with-sub-superscripts/][#orgmode 익스포트 할 때, underscore가 subscripts로 바뀌는 걸 억제 - ohyecloudy.com]]

*** org-drill

    #+begin_quote
    Org-Drill is an extension for Org mode. Org-Drill uses a spaced repetition algorithm to conduct interactive "drill sessions", using org files as sources of facts to be memorised. Each topic is treated as a "flash card".

    [[https://orgmode.org/worg/org-contrib/org-drill.html#org237243a][org-drill.el flashcards and spaced repetition for org-mode - orgmode...]]
    #+end_quote

    간격 학습 반복을 지원하는 org-mode 확장

    #+begin_src elisp :tangle packages.el
      (package! org-drill)
    #+end_src

*** org-mode

    현재 heading을 포함한 상위 heading을 bullet list로 전환

    #+begin_src elisp :lexical t
      (defun my/org-copy-parent-headings-as-bullets ()
        "Collect parent headings of the heading that the cursor belongs to,
      convert them into a bullet list, and copy the result to the clipboard.
      TODO/DONE states are removed."
        (interactive)
        (unless (derived-mode-p 'org-mode)
          (user-error "This command can only be used in org-mode."))

        (save-excursion
          ;; Move to the heading that the cursor belongs to
          (org-back-to-heading t)

          (let ((parents '()))
            (let ((current (org-get-heading t t t t)))
              (setq parents (append parents (list current))))

            ;; Collect parent headings by moving upward
            (while (org-up-heading-safe)
              (push (org-get-heading t t t t) parents))

            (if (null parents)
                (message "No parent headings found.")
              (let ((bullets (mapconcat (lambda (h) (concat "- " h)) parents "\n")))
                (kill-new bullets)
                (message "Copied parent headings as bullet list:\n%s" bullets))))))
    #+end_src

** doom-modeline

   #+begin_src elisp
     (after! doom-modeline
       (setq
        ;; 현재 위치를 쬐깐하게 보여준다
        doom-modeline-hud t
        ;; 경로가 아니라 파일 이름만 모드라인에 보여준다. 'auto는 경로를 출력한다
        ;; tramp로 원격 파일 편집시 느려지는 경험을 완화해준다고 한다
        doom-modeline-buffer-file-name-style 'file-name
        ;; evil mode indicator를 모드라인까지 보여줄 필요 없다. 커서 모양이랑 중복이다. 아껴쓰자.
        doom-modeline-modal nil))
   #+end_src

   doom-modeline 추가 설정

** magit

   #+begin_src elisp
     (after! magit
       (setq magit-save-repository-buffers 'dontask))
   #+end_src

   magit status를 실행하면 묻지 않고 수정한 버퍼를 저장한다

** projectile

   #+begin_src elisp
     (after! projectile
       (setq projectile-indexing-method 'hybrid))
   #+end_src

   =.git= 디렉터리를 같이 사용하는 인덱싱

** company

   #+begin_src elisp
     (after! company
       (setq company-show-quick-access t))
   #+end_src

   =M-1=, =M-0= 까지 숫자로 빠르게 삽입할 수 있는데, 그 숫자를 옆에 출력하게 한다.

** request

   #+begin_src elisp :tangle packages.el
     (package! request)
   #+end_src

   http를 쉽게 사용할 수 있는 request 패키지
   [[https://github.com/tkf/emacs-request][tkf/emacs-request - github.com]]

** mermaid

   #+begin_src elisp :tangle packages.el
     (package! mermaid-mode)
     (package! ob-mermaid)
   #+end_src

   mermaid 구문 강조와 들여쓰기 등을 지원하는 [[https://github.com/abrochard/mermaid-mode][abrochard/mermaid-mode]]를 설치한다. 그리고 org mode에서 mermaid 소스 코드 블럭을 사용할 수 있게 하는 [[https://github.com/arnm/ob-mermaid][arnm/ob-mermaid]]도 추가로 설치한다.

   #+begin_src elisp
     (after! ob-mermaid
       (org-babel-do-load-languages 'org-babel-load-languages
                                    (append org-babel-load-languages
                                            '((mermaid . t)))))
   #+end_src

   org-babel 언어로 =mermaid= 를 추가해서 소스 코드 블럭 컴파일을 할 수 있게 한다.

   #+begin_src elisp
     (when IS-WINDOWS
       (setq mermaid-mmdc-location "~/bin.local/mermaid-cli/node_modules/.bin/mmdc.cmd"))
   #+end_src

   #+begin_src elisp
     (when IS-WINDOWS
       (setq ob-mermaid-cli-path "~/bin.local/mermaid-cli/node_modules/.bin/mmdc.cmd"))
   #+end_src

   windows에서는 직접 설치하고 경로를 지정한다.

** evil

   #+begin_src elisp
     (setq! evil-want-C-w-delete nil)
   #+end_src

   =insert mode= 에서 =C-w= 키를 입력할 때, back word를 지우는 기능을 끈다. 창 전환 키랑 헷갈려서 실수로 단어를 지우는 경우가 많았다.

   #+begin_src elisp
     (after! evil
       (evil-select-search-module 'evil-search-module 'isearch))
   #+end_src

   folded 컨텐츠 검색이 안 되서 workaround 적용. [[https://github.com/doomemacs/doomemacs/issues/6478][doomemacs/doomemacs/issues/6478 - github.com]] 참고

   #+begin_src elisp
     (after! evil
       (setq evil-complete-all-buffers nil))
   #+end_src

   현재 버퍼를 대상으로 완성(completion) 후보를 추린다. 기본값은 열려 있는 전체 버퍼 대상. =C-n=, =C-p= 키 바인딩에서 사용한다.

   #+begin_src elisp
     (after! evil
       (add-hook 'evil-insert-state-exit-hook
                 (lambda ()
                   (setq evil-input-method nil))))
   #+end_src

   [[https://ohyecloudy.com/emacsian/2024/12/07/evil-mode-initialize-input-method/][편집 모드를 나갈 때, 입력기(input method)를 초기화 시킨다]]. 편집 모드로 들어갈 때, 무조건 영문을 기본으로 해서 이전 편집 모드에서 한글을 입력하던 중이었는지 영문을 입력하던 중이었는지 생각할 필요가 없게 한다. 편집 모드로 들어갈 때, 이전 상태를 기억 못하거나 모드 라인(mode line)에 표시된 입력기 상태를 못 봐서 잘못 입력하는 실수를 줄이려고 통일한다.

   #+begin_src elisp
     (setq +evil-want-o/O-to-continue-comments nil)
   #+end_src

   주석을 연속해서 쓰는 경우가 적어서 오히려 불편하다

   #+begin_src elisp :lexical t
     (setq evil-split-window-below t
           evil-vsplit-window-right t)
   #+end_src

   splitting 이후 포커스를 옮긴다

** evil-snipe

   한글도 f/t로 찾을 수 있게 한다.

   #+begin_src elisp :lexical t
     (after! evil-snipe
       (setq evil-snipe-aliases '(
                                  (?r "[rㄱ가-낗]")
                                  (?R "[Rㄲ까-낗]")
                                  (?s "[sㄴ나-닣]")
                                  (?e "[eㄷ다-딯]")
                                  (?E "[Eㄸ따-띻]")
                                  (?f "[fㄹ라-맇]")
                                  (?a "[aㅁ마-밓]")
                                  (?q "[qㅂ바-빟]")
                                  (?Q "[Qㅃ빠-삫]")
                                  (?t "[tㅅ사-싷]")
                                  (?T "[Tㅆ싸-앃]")
                                  (?d "[dㅇ아-잏]")
                                  (?w "[wㅈ자-짛]")
                                  (?W "[Wㅉ짜-찧]")
                                  (?c "[cㅊ차-칳]")
                                  (?z "[zㅋ카-킿]")
                                  (?x "[xㅌ타-팋]")
                                  (?v "[vㅍ파-핗]")
                                  (?g "[gㅎ하-힣]")
                                  )))
   #+end_src

   일괄로 편하게 적용할 수 있는 초성 자음만 찾는다.

** lsp

   #+begin_src elisp
     (after! lsp-mode
       (setq lsp-pwsh-code-formatting-preset "Allman"))
   #+end_src

   [[https://en.wikipedia.org/wiki/Indentation_style#Allman_style][Allman]] 스타일로 포맷팅한다.

   #+begin_src elisp
     (after! lsp-mode
       (setq lsp-pwsh-code-formatting-pipeline-indentation-style "IncreaseIndentationForFirstPipeline"))
   #+end_src

   파이프라인 들여쓰기를 해서 더 보기 좋게 한다.

   참고: [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pwsh/][Powershell - LSP Mode - LSP support for Emacs - emacs-lsp.github.io]]

   #+begin_src elisp
     (when IS-WINDOWS
       (after! lsp-mode
         (setq lsp-csharp-omnisharp-roslyn-download-url
               (concat "https://github.com/omnisharp/omnisharp-roslyn/releases/latest/download/"
                       "omnisharp-win-x64-net6.0.zip"))))
   #+end_src

   windows에서는 =omnisharp-win-x64.zip= 파일을 다운로드 받고 있어서 직접 지정

   #+begin_src elisp
     (after! lsp-mode
       (setq lsp-elixir-ls-version "v0.23.0")
       (setq lsp-elixir-ls-download-url
             (format "https://github.com/elixir-lsp/elixir-ls/releases/download/%s/elixir-ls-%s.zip"
                     lsp-elixir-ls-version
                     lsp-elixir-ls-version))
       )
   #+end_src

   default [[https://github.com/elixir-lsp/elixir-ls][elixir-ls]] 버전이 낮아서 최신 버전을 지정

** consult

   [[https://github.com/git-for-windows/build-extra][Git for Windows SDK]]로 설치한 =locate= 프로그램이 제대로 동작하지 않는다. windows에서 더 최적화된 [[https://www.voidtools.com/ko-kr/][Everything]]을 파일 찾기에 사용한다.

   #+begin_src elisp
     (when IS-WINDOWS
       (after! consult
         (setq consult-locate-args "es")
         )
       )
   #+end_src

   macOS 기본 locate 프로그램은 =--ignore-case= 옵션을 지원하지 않음. 같은 역할을 하는 =-i= 옵션으로 대체

   #+begin_src elisp :lexical t
     (when IS-MAC
       (after! consult
         (setq consult-locate-args "locate -i")
         )
       )
   #+end_src

** vertico

   #+begin_src elisp :exports both
     (after! vertico
       (defun my/vertico-setup-then-remove-post-command-hook (&rest args)
         "vertico--setup 함수에서 추가하는 post-command-hook을 제거한다.

     입력 조합으로 표현하는 한글 입력시 post-command-hook이 입력되지 않는다.
     한글 증분 완성을 위해 timer로 호출하기 때문에 제거한다"
         (remove-hook 'post-command-hook #'vertico--exhibit 'local))

       (defun my/vertico-exhibit-with-timer (&rest args)
         "타이머를 넣어 타이머 이벤트 발생시 vertico--exhibit을 호출해 미니버퍼 완성(completion) 후보 리스트를 갱신한다

     post-command-hook이 발동하지 않는 한글 입력시에도 한글 증분 완성을 하기 위해 timer를 사용한다"
         (let (timer)
           (unwind-protect
               (progn
                 (setq timer (run-with-idle-timer
                              0.01
                              'repeat
                              (lambda ()
                                (with-selected-window (or (active-minibuffer-window)
                                                          (minibuffer-window))
                                  (vertico--exhibit))
                                )))
                 (apply args))
             (when timer (cancel-timer timer)))))

       (advice-add #'vertico--setup :after #'my/vertico-setup-then-remove-post-command-hook)
       (advice-add #'vertico--advice :around #'my/vertico-exhibit-with-timer))
   #+end_src

   vertico는 =post-command-hook= 을 사용해서 증분 완성(incremental completion)을 수행한다. 영문 입력시 =post-command-hook= 이 잘 발동하지만 조합해서 입력하는 한글은 =post-command-hook= 이 호출되지 않는다. helm 동작 방법을 참고해 timer를 돌려서 해결했다.

   빠른 접근을 위해 =vertico-indexed-mode= 활성화

   #+begin_src elisp :lexical t
     (after! vertico
       (vertico-indexed-mode 1))
   #+end_src

   =C-NUM RET= 키로 동작한다. 5번이 붙은 후보를 바로 사용하려면 =C-5 RET= 키를 누르면 된다.

** atomic-chrome

    #+begin_src elisp :tangle packages.el
      (package! atomic-chrome)
    #+end_src

    #+begin_src elisp :lexical t
      (atomic-chrome-start-server)
    #+end_src

    웹브라우저 textarea를 emacs로 편집할 수 있게 해준다. [[https://chrome.google.com/webstore/detail/ghosttext/godiecgffnchndlihlpaajjcplehddca/related][GhostText 크롬 확장]]을 설치해야 한다. 크롬뿐만 아니라 거의 대부분의 웹브라우저를 다 지원한다. 웹브라우저 확장과 통신할 [[https://github.com/alpha22jp/atomic-chrome][atomic-chrome]] 패키지를 설치한다.

    GhostText 홈페이지: [[https://ghosttext.fregante.com/][GhostText — Use your text editor in the browser - ghosttext.fregante.com]]

** org-ai

   #+begin_src elisp :tangle packages.el
     (when IS-MAC
       (package! org-ai))
   #+end_src

   #+begin_src elisp
     (when IS-MAC
       (use-package! org-ai
         :commands (org-ai-mode
                    org-ai-global-mode)
         :init
         (add-hook 'org-mode-hook #'org-ai-mode) ; enable org-ai in org-mode
         (org-ai-global-mode) ; installs global keybindings on C-c M-a
         :config
         (setq org-ai-default-chat-model "gpt-3.5-turbo")
         (org-ai-install-yasnippets)) ; if you are using yasnippet and want `ai` snippets
       )
   #+end_src

   OpenAI API key는 =~/.authinfo.gpg= 파일에 다음과 같은 형식으로 기록한다

   #+begin_example
     machine api.openai.com login org-ai password <your-api-key>
   #+end_example

   [[https://github.com/rksm/org-ai][rksm/org-ai - github.com]]

** ox-jekyll-lite

   #+begin_src elisp :tangle packages.el
     (when IS-MAC
       (package! example
         :recipe (:host github :repo "ohyecloudy/ox-jekyll-lite"))
       )
   #+end_src

   #+begin_src elisp
     (when IS-MAC
       (require 'ox-jekyll-lite)
       (setq org-jekyll-lite-include-yaml-front-matter nil))

   #+end_src

   org 파일을 jekyll markdown으로 export하는 라이브러리

   참고: [[https://www.pwills.com/post/2019/09/24/blogging-in-org.html][Blogging in Org Mode - pwills.com - pwills.com]]

** eldoc

   #+begin_src elisp :lexical t
     (after! eldoc
       ;; =M-x eldoc-doc-buffer= 함수 호출로 표시하는 buffer 크기 조절
       (set-popup-rule! "^\\*eldoc for" :size 0.2 :vslot -1)

       ;; eldoc을 여러 백엔드에서 수집해서 보여줄 수 있게 한다
       (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly
             ;; echo area에 최대 4줄까지 보여주게 함
             eldoc-echo-area-use-multiline-p 4))
   #+end_src

** flycheck

   flycheck 메시지를 echo area만 보여주려고 popup tip으로 보여주는 [[https://github.com/flycheck/flycheck-popup-tip][flycheck-popup-tip]] 패키지 비활성화

   #+begin_src elisp :tangle packages.el
     (package! flycheck-popup-tip :disable t)
   #+end_src

   flycheck error를 eldoc 패키지로 출력한다. '[[https://www.masteringemacs.org/article/seamlessly-merge-multiple-documentation-sources-eldoc?utm_source=pocket_saves][Seamlessly Merge Multiple Documentation Sources with Eldoc - Mastering Emacs ...]]' 글에서 코드를 가져와 Doom Emacs에 맞게 변경함

   #+begin_src elisp :lexical t
     (after! flycheck
       (defun my/flycheck-eldoc (callback &rest _ignored)
         "Print flycheck messages at point by calling CALLBACK."
         (when-let ((flycheck-errors (and flycheck-mode (flycheck-overlay-errors-at (point)))))
           (mapc
            (lambda (err)
              (funcall callback
                       (format "%s: %s"
                               (let ((level (flycheck-error-level err)))
                                 (pcase level
                                   ('info (propertize "I" 'face 'flycheck-error-list-info))
                                   ('error (propertize "E" 'face 'flycheck-error-list-error))
                                   ('warning (propertize "W" 'face 'flycheck-error-list-warning))
                                   (_ level)))
                               (flycheck-error-message err))
                       :thing (or (flycheck-error-id err)
                                  (flycheck-error-group err))
                       :face 'font-lock-doc-face))
            flycheck-errors)))

       (defun my/flycheck-prefer-eldoc ()
         (add-hook 'eldoc-documentation-functions #'my/flycheck-eldoc nil t)
         (setq flycheck-display-errors-function nil)
         (setq flycheck-help-echo-function nil))

       (add-hook! 'flycheck-mode-hook #'my/flycheck-prefer-eldoc))
   #+end_src

** which-key

   #+begin_src elisp :lexical t
     (after! which-key
       (setq which-key-idle-delay 0.5))
   #+end_src

   나는 좀 더 빨리 도움이 필요함

** treemacs

   현재 버퍼에 해당 파일을 treemacs 버퍼에서 포커싱하는 follow mode를 활성화한다.

   #+begin_src elisp :lexical t
     (after! treemacs
       (treemacs-follow-mode t))
   #+end_src

   [[https://github.com/Alexander-Miller/treemacs][Alexander-Miller/treemacs - github.com]]

** geiser - Scheme

   org-mode babel에서 scheme을 사용할 수 있게 세팅한다

   #+begin_src elisp :lexical t
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((scheme . t)))
   #+end_src

   source block에서 =:session=, =:var= 를 사용할 수 있다.

   #+begin_example
     ,#+header: :session :var message="Hello World!"
     ,#+begin_src scheme
     message
     ,#+end_src
   #+end_example

** pandoc-mode

   universal document converter인 [[https://pandoc.org/index.html][Pandoc]] 사용 모드. [[https://github.com/joostkremers/pandoc-mode/][joostkremers/pandoc-mode/ - github.com]]

   #+begin_src elisp :tangle packages.el
     (package! pandoc-mode)
   #+end_src

** vlf

   #+begin_quote
   Emacs minor mode that allows viewing, editing, searching and comparing large files in batches, trading memory for processor time. Batch size can be adjusted on the fly and bounds the memory that is to be used for operations on the file. This way multiple large files (like terabytes or whatever) can be instantly and simultaneously accessed without swapping and degraded performance.

   [[github:m00natic/vlfi][m00natic/vlfi - github.com]]
   #+end_quote

   대용량 파일도 잘 열린다

   #+begin_src elisp :tangle packages.el
     (package! vlf)
   #+end_src

* syntax

  #+begin_src elisp
    (add-hook! 'emacs-lisp-mode-hook
               #'(lambda ()
                   (modify-syntax-entry ?_ "w")
                   (modify-syntax-entry ?- "w")))
    (add-hook! 'c-mode-common-hook
               #'(lambda () (modify-syntax-entry ?_ "w")))
    (add-hook! 'elixir-mode-hook
               #'(lambda ()
                   (modify-syntax-entry ?_ "w")
                   (modify-syntax-entry ?: ".")
                   (modify-syntax-entry ?% ".")))
  #+end_src

  =kebab-case=, =snake_case= 처리 친화적으로 문자를 word로 추가한다. [[http://ohyecloudy.com/emacsian/2017/12/16/evil-syntax-table-kebab-case-snake-case-friendly/][#evilmode kebab-case, snake_case 처리 친화적으로 - '_' 문자나 '-' 문자를 word 취급]] 참고

* my packages

  #+begin_src elisp
    (add-load-path! (expand-file-name "lisp/" doom-user-dir))
  #+end_src

  =c44bc81a05= commit id에서 =9d4d5b756a= commit id로 업데이트한 이후로 =(add-load-path! "lisp")= 가 동작하지 않는다. =load-path= 변수를 확인해본 결과 =.doom.d= 디렉터리가 아니라 =.emacs.d= 디렉터리를 기준으로 =lisp= 디렉터리가 =load-path= 로 추가된 걸 확인했다. 그래서 =doom-user-dir= 을 기준으로 한 load path를 계산해 명시적으로 할당한다.

** my-build-link-section

   #+begin_src elisp
     (require 'my-build-link-section)
   #+end_src

   =M-x my/build-link-section= 함수로 본문에 있는 링크를 수집해서 링크 org heading을 만들어준다.

   참고: [[http://ohyecloudy.com/emacsian/2022/05/28/create-link-section-by-scraping-links-from-current-org-docs/][org 문서에서 링크를 긁어서 링크 섹션을 만들기 - ohyecloudy.com]]

** ox-confluence

   #+begin_src elisp
     (require 'my-ox-confluence)
   #+end_src

   [[https://github.com/aspiers/orgmode/blob/master/contrib/lisp/ox-confluence.el][aspiers/orgmode/blob/master/contrib/lisp/ox-confluence.el - github.com]] 파일을 가져와서 조금 고친 패키지. confluence 마크업으로 익스포트를 지원한다.

** ox-taskjuggler

   #+begin_src elisp :tangle no
     (require 'ox-taskjuggler)
     (progn
       (load-file (expand-file-name "lisp/taskjuggler-setting.el" doom-user-dir))
       (setq org-taskjuggler-reports-directory "~/taskjuggler")
       ;; 넉넉하게 잡아놔서 Error: Some tasks did not fit into the project time frame. 에러가 안 뜨게 한다
       (setq org-taskjuggler-default-project-duration 999))
   #+end_src

   [[https://taskjuggler.org/][taskjuggler]] 라이브러리를 exporter로 사용하는 [[https://orgmode.org/worg/exporters/taskjuggler/ox-taskjuggler.html][ox-taskjuggler]] 세팅

** my-gitlab

   #+begin_src elisp
     (require 'my-gitlab)
     (require 'legacy-gitlab)
   #+end_src

   gitlab을 사용하면서 만들어놓은 함수

   [[http://ohyecloudy.com/emacsian/2023/04/22/auth-source-easypg/][auth-source]]에 다음과 같은 private token 정보가 저장되어 있어야 한다.

   #+begin_example
     machine mygitlab.com login NOT_USED password [PRIVATE-TOKEN]
   #+end_example

   URL을 보고 API에 접근해야할 지 판단한다. 판단 근거로 사용할 host 정보를 세팅해야 한다

   #+begin_src elisp :lexical t :tangle no
     (add-to-list 'my/gitlab-hosts '(:url "http://mygitlab.com"
                                     :api-url "http://mygitlab.com/api/v4"))
   #+end_src

   gitlab merge request 삽입은 두 가지 방법으로 지원한다.

   =SPC m z g= 키로 클립보드에 저장된 URL 혹은 입력 받아서 해당 merge request 정보로 org heading을 삽입한다.

   #+begin_src elisp :lexical t
     (map! :map org-mode-map
           :localleader
           (:prefix ("z" . "insert")
                    "g" #'my/gitlab-insert-heading-content))
   #+end_src

   혹은 =SPC m l c= 키로 클립보드에 저장된 URL을 org-cliplink 패키지로 링크 마크업을 삽입한다. 아래 =my-org-cliplink-confluence= 세팅 참고

** ob-csharp

   #+begin_src elisp
     (require 'ob-cs)

     (org-babel-do-load-languages 'org-babel-load-languages
                                  (append org-babel-load-languages
                                          '((cs . t))))

     (after! org
       (add-to-list 'org-src-lang-modes '("cs" . "csharp")))
   #+end_src

   [[https://github.com/thomas-villagers/ob-csharp][ob-csharp]]에 [[https://github.com/dotnet-script/dotnet-script ][dotnet-script]]를 사용한 [[https://github.com/thomas-villagers/ob-csharp/pull/2][PR]]을 적용했다.

   doom emacs에서 org-contrib를 로드할 때, ob-csharp을 로드한다. 이걸 갈아치는 방법을 못 찾아서 이름을 바꿔서 적용한다.

   #+begin_src org :tangle no
     ,#+begin_src cs
       Console.WriteLine("hello org babel")
     ,#+end_src
   #+end_src

   source code 이름은 =cs= 를 사용한다.

** my-source-mine

   #+begin_src elisp
     (require 'my-source-mine)
   #+end_src

   언어별 참고할만한 코드베이스를 저장한 디렉터리에서 바로 검색하는 패키지. 소스 광산(source mine)이라고 부르자. doom emacs의 함수를 사용해서 구현했다.

   #+begin_src elisp
     (map! :leader
           (:prefix-map ("S" . "custom search")
                        (:prefix-map ("m" . "source mine")
                         :desc "elixir" "x" #'my/source-mine-elixir)))
   #+end_src

   elixir 소스 광산을 검색하려면 =SPC S m x= 키를 누르면 된다.

   #+begin_example
     machine source_mine login elixir password ~/source_mine/elixir
   #+end_example

   소스 광산 디렉터리는 auth-source 패키지를 사용한다. 이런 식으로 =~/.authinfo= 에 저장하면 된다.

** my-jira

   #+begin_src elisp
     (require 'my-jira)
   #+end_src

   비공개 Jira 페이지 정보 삽입을 지원하기 위해 jira rest api를 사용한다. 옛날 버전도 지원하는 척 하지만 현재는 jira cloud만 지원한다.

   [[http://ohyecloudy.com/emacsian/2023/04/22/auth-source-easypg/][auth-source]]에 다음과 같은 id, api key 정보가 저장되어 있어야 한다.

   #+begin_example
     machine some.atlassian.net/browse login ohyecloudy@email.com password [API-KEY]
   #+end_example

   URL을 보고 API에 접근해야할 지 판단한다. 판단 근거로 사용할 host 정보를 세팅해야 한다

   #+begin_src elisp :lexical t :tangle no
     (add-to-list 'my/jira-hosts '(:url "https://some.atlassian.net/browse"
                                   :api-url "https://some.atlassian.net/rest"
                                   :api-version :cloud))
   #+end_src

   jira 이슈 삽입은 두 가지를 지원한다.

   =SPC m z j= 키로 클립보드에 저장된 URL 혹은 입력 받아서 해당 이슈 정보로 org heading을 삽입한다.

   #+begin_src elisp :lexical t
     (map! :map org-mode-map
           :localleader
           (:prefix ("z" . "insert")
                    "j" #'my/jira-insert-heading-content))
   #+end_src

   혹은 =SPC m l c= 키로 클립보드에 저장된 URL을 org-cliplink 패키지로 링크 마크업을 삽입한다. 아래 =my-org-cliplink-confluence= 세팅 참고

** my-swarm

   #+begin_src elisp
     (require 'my-swarm)
   #+end_src

   api base 주소, project 이름, username, p4 ticket은 auth-source를 사용해서 접근한다. p4 ticket만 넣으려고 했는데, 귀찮아서 로컬에서 저장하는 걸 싹다 넣음

   #+begin_example
     machine myswarm login username password MYUSERNAME
     machine myswarm login ticket password SUPERSECRET
     machine myswarm login host password https://helixswarm.com
     machine myswarm login project password AWESOME_PROJECT
   #+end_example

   이런식으로 =~/.authinfo= 파일에 저장하면 된다.

** my-org-cliplink

   =title - ohyecloudy.com= 식으로 org link를 만드는 org-cliplink에 취향을 가미한 라이브러리를 로드한다.

   #+begin_src elisp
     (require 'my-org-cliplink)
   #+end_src

   =org-clinklink= 함수에 바인딩된 키를 =my/org-cliplink= 로 바인딩한다.

   #+begin_src elisp
     (after! org
       (define-key org-mode-map [remap org-cliplink] 'my/org-cliplink))
   #+end_src

   타이틀 뒤에 붙는 호스트 이름을 가공할 수 있다.

   #+begin_src elisp :lexical t :tangle no
     (add-to-list 'my/org-cliplink-host-transform-rules '("github.com" "GitHub"))
   #+end_src

** my-org-cliplink-confluence

   Confluence 페이지는 API를 사용해 정보를 가져와서 org-cliplink처럼 org-mode 링크 markup을 추가한다. 비공개 Confluence 페이지 정보 삽입도 지원한다.

   Confluence 6.x 버전과 Confluence Cloud v2를 지원한다. 둘 다 HTTP 기본 인증을 사용한다.

   [[http://ohyecloudy.com/emacsian/2023/04/22/auth-source-easypg/][auth-source]]에 다음과 같은 id, password(cloud는 api key) 정보가 저장되어 있어야 한다.

   #+begin_example
     machine CONFLUENCE_6_HOST/confluence login ohyecloudy password SUPER_SECRET_PASSWORD
     machine CONFLUENCE_CLOUD_HOST/wiki login ohyecloudy password SUPER_SECRET_API_KEY
   #+end_example

   url과 api-version을 리스트에 추가한다.

   #+begin_src elisp :lexical t :tangle no
     (add-to-list 'my/org-cliplink-confluence-hosts '(:url "https://CONFLUENCE_CLOUD_HOST/wiki" :api-version :cloud))
     (add-to-list 'my/org-cliplink-confluence-hosts '(:url "http://CONFLUENCE_6_HOST/confluence" :api-version 6))
     (add-to-list 'my/org-cliplink-confluence-hosts '(:url "https://CONFLUENCE_6_HOST/confluence" :api-version 6))
   #+end_src

   #+begin_src elisp
     (require 'my-org-cliplink)
     (require 'my-org-cliplink-confluence)
   #+end_src

   Confluence API 혹은 Jira API를 사용해서 페이지 정보를 가져올 수 있게 org-cliplink 커스텀 함수를 정의한다.

   #+begin_src elisp :lexical t
     (setq my/org-cliplink-custom-retrieve-title-hook
           (lambda (url)
             (or (my/org-cliplink-confluence-title url)
                 (my/jira-title url)
                 (my/gitlab-merge-request-title url))))
   #+end_src

** my-web-archive

   [[https://web.archive.org/][Web Archive]] 서비스에 URL을 요청해 아카이브 URL을 가져오는 패키지를 로드한다. 아카이브 URL을 가져오는 함수를 적용할 패키지인 my-org-cliplink, my-build-link-section를 같이 로드한다.

   #+begin_src elisp :lexical t
     (require 'my-web-archive)
     (require 'my-org-cliplink)
     (require 'my-build-link-section)
   #+end_src

   =my-org-cliplink= 패키지를 사용해 아카이브 URL 뿐만 아니라 웹페이지 타이틀도 가져와서 링크를 만들게 한다.

   #+begin_src elisp :lexical t
     (defun my/web-archive-with-webpage-title (url archive-url)
       (org-cliplink-retrieve-title
        url
        (lambda (url title)
          (let* ((origin-org-link (my/org-cliplink-link-transformer url title))
                 (archive-link (format "([[%s][archive]])" archive-url)))
            (my/web-archive-write-line my/web-archive-result-buffer-name
                                       (format "%s%s" origin-org-link archive-link))))))
   #+end_src

   클립보드 컨텐츠를 가져와 링크를 만드는 함수를 정의한다.

   #+begin_src elisp :lexical t
     (defun my/org-cliplink-with-archive-url ()
       (interactive)
       (my/web-archive-async (list (org-cliplink-clipboard-content))
                             #'my/web-archive-with-webpage-title))
   #+end_src

   타이틀만 가져와서 링크를 만드는 키바인딩 =SPC m l c= 에서 c를 대문자로 입력하면 아카이브 URL도 같이 가져온다.

   #+begin_src elisp :lexical t
     (after! org
       (map! :map org-mode-map
             :localleader
             (:prefix ("l" . "links")
                      "C" #'my/org-cliplink-with-archive-url)))
   #+end_src

   org 문서에 있는 링크를 긁고 아카이브 URL도 같이 추가할 수 있게 =my/build-link-section= 패키지 함수를 확장.

   #+begin_src elisp :lexical t
     (defun my/build-link-section-with-archive-urls-async ()
       (interactive)
       (my/build-link-section (lambda (links)
                                (my/web-archive-async links
                                                      #'my/web-archive-with-webpage-title))))
   #+end_src

** my-open-log-file

   =tail -f= 로 파일을 연 것처럼 Emacs 버퍼로 파일을 연다.

   =my/project-log-path= 변수에 프로젝트 이름과 로그 파일 path를 association list로 정의한다.

   #+begin_src elisp :tangle no
     (setq my/project-log-path '(("project 1" . "~/some.log")
                                 ("project 2" . "~/project2/logs/log.txt")))
   #+end_src

   #+begin_src elisp :lexical t
     (defun my/open-log-file (project-log-key)
       (interactive
        (list
         (completing-read "project: " (mapcar #'car my/project-log-path))))
       (let ((path (cdr (assoc project-log-key my/project-log-path))))
         (if (file-exists-p path)
             (progn
               (find-file-other-window path)
               ;; Warning (org-element): ‘org-element-at-point’ cannot be used
               ;; 이 워닝 못 잡겠다. 무시
               (setq warning-suppress-types '((org-element)))

               (fundamental-mode)
               (read-only-mode 1)
               (buffer-disable-undo)
               (when (boundp 'font-lock-mode)
                 (font-lock-mode -1))
               (when (fboundp 'so-long-minor-mode)
                 (so-long-minor-mode 1))

               (setq-local auto-revert-interval 1.0)
               (auto-revert-tail-mode 1)

               (goto-char (point-max)))
           (message (concat "log file not found - " path)))))
   #+end_src

   =SPC o q= 바인딩으로 로그 파일을 열 수 있다

   #+begin_src elisp :lexical t
     (map! :leader
           (:prefix-map ("o" . "open")
            :desc "Open log file" "q" #'my/open-log-file))
   #+end_src

   [[https://ohyecloudy.com/emacsian/2017/12/02/auto-revert-tail-mode/][tail -f {unity 로그 파일} - (emacsian ohyecloudy) - ohyecloudy.com]] 참고

** my-org-bulk-export-jekyll

   jekyll 소스 org 파일을 한 번에 md로 익스포트하는 라이브러리

   #+begin_src elisp :lexical t
     (require 'my-org-bulk-export-jekyll)
   #+end_src

* my functions

  #+begin_src elisp
    ;;; http://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/
    (defun copy-file-name-to-clipboard ()
      "Copy the current buffer file name to the clipboard."
      (interactive)
      (let ((filename (if (equal major-mode 'ranger-mode)
                          default-directory
                        (buffer-file-name))))
        (when filename
          (kill-new filename)
          (message "Copied buffer file name '%s' to the clipboard." filename))))

    (defun jekyll-default-image ()
      (interactive)
      (let ((name (format "{{ site.asseturl }}/%s-00.jpg"
                          (file-name-base (buffer-file-name)))))
        (kill-new name)
        (message "Copied default image name '%s' to the clipboard." name)))

    (defun toggle-camelcase-underscores ()
      "Toggle between camelcase and underscore notation for the symbol at point."
      (interactive)
      (save-excursion
        (let* ((bounds (bounds-of-thing-at-point 'symbol))
               (start (car bounds))
               (end (cdr bounds))
               (currently-using-underscores-p (progn (goto-char start)
                                                     (re-search-forward "_" end t))))
          (if currently-using-underscores-p
              (progn
                (upcase-initials-region start end)
                (replace-string "_" "" nil start end)
                (downcase-region start (1+ start)))
            (replace-regexp "\\([A-Z]\\)" "_\\1" nil (1+ start) end)
            (downcase-region start (cdr (bounds-of-thing-at-point 'symbol)))))))

    (require 'subr-x)
    (defun open-issue-page ()
      (interactive)
      (when (not (boundp 'issue-base-page)) (throw 'issue-base-page "not bound"))
      (let* ((line (thing-at-point 'line))
             ;; issue number를 못 찾았을 때, number가 nil이 되야 하는데, 공백 문자가 들어간다
             ;; 원인을 못 찾아서 string trim을 한 후 길이를 재서 검사한다.
             (number (find-issue-number line)))
        (if (> (length (string-trim number)) 0)
            (browse-url (format "%s/%s" issue-base-page number))
          (message "failed find issue number - %s" line))))

    (defun find-issue-number (line)
      (save-match-data
        (string-match "#\\([0-9]+\\)" line)
        (match-string 1 line)))

    (defun unevernotify ()
      (interactive)
      (while (re-search-forward "\u00a0" nil t)
        (replace-match " ")))
  #+end_src

* windows coding system

  #+begin_src elisp
    (when IS-WINDOWS
      (setq default-process-coding-system '(utf-8 . cp949)))
  #+end_src

  windows에서는 프로세스로 보내는 coding system을 cp949로 고정한다. =bashrc= 에서 =chcp.com 65001= 을 실행하게 해도 =rg.exe= 파일을 실행하는 프로세스에 =utf-8= 인코딩으로 보내면 동작하지 않는다. 정확한 원인은 찾지 못했다.

* =browse-url= 에서 사용하는 프로그램을 =chrome= 으로 변경

  #+begin_src elisp
    (when IS-WINDOWS
      (setq browse-url-chrome-program "run-chrome.bat")
      (setq browse-url-handlers
            '(("nexon.com" . browse-url-default-browser)
              ("." . browse-url-chrome))))
  #+end_src

  윈도우에서는 기본 브라우저를 =chrome= 이 아닌 다른 프로그램으로 설정할 때가 많아서 emacs에서 url로 열 때는 =chrome= 으로 고정. 이후 macOS에도 일괄 적용.

* windows bash shell

  #+begin_src elisp
    ;; windows에서 shell을 사용할 때, windows에서 사용하는 code page도 UTF-8로 변경한다
    ;; 그렇게 하려고 -l 옵션을 붙여서 로그인을 한다. 그 결과 interactive 모드로 셸을 실행한다
    ;; interactive 모드로 실행해서 ~/.bashrc 셸 스크립트 파일을 실행하게 한다.
    ;; ~/.bashrc 파일에서 windows일 때, chcp.com 65001 명령을 실행해서 code page도 UTF-8로 변경한다.
    ;;
    ;; -i 옵션은 job control 생성을 못해서 대신 -l 옵션을 사용했다.
    ;; bash: cannot set terminal process group (-1): Inappropriate ioctl for device
    ;; bash: no job control in this shell
    (when IS-WINDOWS
      (setq shell-command-switch "-lc"))

    ;;; shell
    (when IS-WINDOWS
      (let* ((combine-path (lambda (dir dir-or-file)
                             (concat (file-name-as-directory dir) dir-or-file)))
             (base-dir "C:/git-sdk-64")
             (mingw64-bin-dir (funcall combine-path base-dir "mingw64/bin"))
             (msys2-bin-dir (funcall combine-path base-dir "usr/bin"))
             (bash-path (funcall combine-path msys2-bin-dir "bash.exe")))
        (add-to-list 'exec-path msys2-bin-dir)
        (add-to-list 'exec-path mingw64-bin-dir)
        (setq explicit-shell-file-name bash-path)
        (setq shell-file-name bash-path)
        (setenv "SHELL" bash-path)
        (setq explicit-bash.exe-args '("--noediting" "--login" "-i"))
        (setenv "PATH" (concat mingw64-bin-dir path-separator
                               (concat msys2-bin-dir path-separator
                                       (getenv "PATH"))))))
  #+end_src

  windows에서 git sdk를 깔 때, 설치한 bash를 shell로 설정한다.

* macOS compile options

  #+begin_src elisp :exports both
    (when IS-MAC
      (customize-set-variable 'native-comp-driver-options '("-Wl,-w")))
  #+end_src

  #+begin_example
    ld: warning: -undefined dynamic_lookup may not work with chained fixups
  #+end_example

  이런 에러가 보이는 걸 발견. '[[https://www.reddit.com/r/emacs/comments/xfhnzz/weird_errors_with_latest_build_of_emacs/][Reddit - Dive into anything - reddit.com]]' 에서 해결 방법을 찾음

* load config.local.el

  #+begin_src elisp :lexical t
    (load! "config.local.el" doom-user-dir t)
  #+end_src

  버전 컨트롤하지 않고 로컬에만 담아둔 설정을 로드한다.

* find or browse dotfiles

  =SPC f t=, =SPC f T= 로 dotfiles 디렉터리에서 find 하거나 browse 한다. [[https://github.com/hlissner/.doom.d/blob/master/config.el][hlissner/.doom.d/blob/master/config.el - github.com]] 에서 가져옴

  #+begin_src elisp :lexical t
    (map! (:leader
           (:prefix "f"
                    "t" #'find-in-dotfiles
                    "T" #'browse-dotfiles)))

    (defun find-in-dotfiles ()
      "Open a file somewhere in ~/.dotfiles via a fuzzy filename search."
      (interactive)
      (doom-project-find-file (expand-file-name "~/.dotfiles")))

    (defun browse-dotfiles ()
      "Browse the files in ~/.dotfiles."
      (interactive)
      (doom-project-browse (expand-file-name "~/.dotfiles")))
  #+end_src

* etc

  #+begin_src elisp :lexical t
    (setq-default major-mode 'org-mode)
  #+end_src

  디폴트 메이저 모드로 org-mode를 사용한다. fundamental mode를 거의 사용하지 않아서 자주 사용하는 org-mode로 세팅

* TODO 설정

  #+begin_src elisp :tangle no
    ;; tab으로 electic pair 밖으로 나올 수 있게 한다
    ;; https://www.reddit.com/r/emacs/comments/3n1j4x/anyway_to_tab_out_of_parentheses/
    (progn
      (defun smart-tab-jump-out-or-indent (&optional arg)
        (interactive "P")
        (let ((closings (mapcar #'cdr electric-pair-pairs))
              (after (char-after)))
          (if (member after closings)
              (forward-char 1)
            (indent-for-tab-command arg))))

      (global-set-key [remap indent-for-tab-command] #'smart-tab-jump-out-or-indent))
  #+end_src
